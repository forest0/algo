---
title: "区间相关问题"
date: 2020-11-13T10:01:59+08:00
draft: false
series:
  - AOAPC
tags:
  - Greedy
---

## 选择不相交区间

数轴上有$n$个开区间$(a_i, b_i)$。
选择尽量多的区间，使得这些区间两两没有公共点。

### 分析

首先明确：假设有两个区间$x,y$，区间$x$完全包含$y$，
那么我们一定不选$x$，因为$x,y$最多选一个，
选$y$还留下了更多的位置。

接下来，将所有区间按$b_i$升序排列。
贪心选择策略为：一定要选第一个区间。

现在区间已经排序为$b_1 \leqslant b_2 \leqslant b_3 \cdots$，
考虑$a_1$和$a_2$的大小关系。

**情形1**: $a_1 > a_2$，此时区间2包含区间1，由上所述，
一定不选择区间2。不仅区间2如此，对于后边的区间$i$，
只要有$a_1 > a_i$，都不选区间$i$。后边的讨论中，
不考虑这些区间。

**情形2**: 排除情形1后，一定有$a_1 \leqslant a_2 \leqslant a_3 \cdots$。
如果区间1和区间2完全不相交，那么没有影响，一定会选择区间1；
否则区间1和区间2相交，最多从中选择一个。
如果不选区间2，那么区间1的$(a_1,a_3)$部分没有影响（它不会挡住任何一个区间）,
区间1的有效部分变为$(a_3,b_1)$，而这部分被区间2包含，由上所述，不会选择区间2。
以此类推，不能因为选任何区间而放弃区间1，因此选择区间1是明智的。

{{< admonition type=info >}}
这里有点绕，画下图就明白了。
{{< /admonition >}}

### 实现

选择区间1后，把所有和区间1相交的区间排除在外，转换为了子问题求解。
具体实现时，按区间右端升序排列，第一个必选。记录上次被选择的区间，
跳过所有和上次选择的区间相交的区间，扫描一遍完成求解。


## 区间选点

数轴上由$n$个闭区间$[a_i, b_i]$。取尽量少的点，
使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）。

### 分析

如果区间$i$内已经有一个点被取到，则称此区间已经被满足。
与上边*选择不相交区间*问题类似，如果小区间被大区间包含，
小区间满足则必有大区间满足。所以有区间包含的情况，
大区间不需要考虑。

把所有区间按$b$升序排列（$b$相同时按$a$降序排列），
则若出现区间包含的情形，小区间一定排在前边。
第一个区间应该取哪个点呢？贪心选择策略为：选择该区间最后一个点。

不考虑大区间包含小区间的情形后，现在所有$a$也是升序排列的。
如果第一个区间中选择的点不是最后一个，而是取更靠前的，
那么将其移动到最后，原先被改点覆盖的区间依旧能够被覆盖，
并且有可能覆盖到原先未被覆盖到的区间，因此该贪心选择策略是正确的。

### 实现

把所有区间按$b$升序排列（$b$相同时按$a$降序排列），
在当前的第一个区间选择最后一个点，排除掉该点覆盖的所有区间，
扫描一遍完成求解。


## 区间覆盖

数轴上由$n$个闭区间$[a_i, b_i]$，
取尽量少的区间覆盖一条指定线段$[s,t]$。

### 分析

同上两个问题，突破口仍是区间包含和排序扫描。
不过之前应该先进行一次预处理，每个区间在$[s,t]$之外的部分都应该被切掉，
因为它们的存在毫无意义。预处理后，对于区间包含的情形，小区间显然不予考虑。

把各区间按$a$升序排列。如果区间1的起点不是$s$，则无解
（因为其它区间的起点更大，不可能覆盖到$s$）；
否则应该选择起点在$s$的最长区间$[a_i, b_i]$。
选择此区间后，新的起点变为$b_i$，忽略所有区间在$b_i$之前的部分，
就像预处理一样，变为了相同的子问题求解。

### 实现

实际上，我们并不需要真的去切。先把各区间按$a$升序排列，
设当前起点为$c$，从前到后考虑所有能覆盖到$c$的区间，
从中选择$b$最大的区间$[a_i,b_i]$。将当前起点改为$b_i$，
继续向后扫描，跳过中间不能覆盖到$b_i$的区间。
